#include <bits/stdc++.h>
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// #define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>
using namespace std;
#define int long long
#define sp " "
#define endl "\n"
#define vi vector<int>
#define all(a) a.begin(), a.end()
#define ON(n, k) ((n | (1 << k)))
#define OFF(n, k) (((n) & ~(1 << (k))))
#define isON(n, k) (((n) >> (k)) & 1)
#define JOE ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define files freopen("input.txt","r",stdin), freopen("output.txt","w",stdout);


// fast power and LCM and GCD.
int GCD(int a,int b) {
    if (b == 0) return a;
    return GCD(b, a % b);
}

int LCM(int a,int b) {
    return a * (b / GCD(a, b));
}

int nCR_without_MOD(int n, int r) // without overflow also.
{
    if (r <= 0 || r > n)
        return 0;
    int sum = 1;
    for (int i = 1; i <= r; i++) {
        sum = sum * (n - r + i) / i;
    }
    return sum;
}

int fastpow(int n, int m) {
    int ret = 1;
    while (m > 0) {
        if (m & 1)
            (ret *= n);
        (n *= n);
        m >>= 1;
    }
    return ret;
}

int b1 = 127, b2 = 131, m1 = 1e9 + 7, m2 = 1e9 + 9;
vi power1, power2;

void gen(int n) {
    power1.resize(n + 1), power2.resize(n + 1);
    power1[0] = power2[0] = 1;
    for (int i = 1; i <= n; i++) {
        power1[i] = (power1[i - 1] * b1) % m1;
        power2[i] = (power2[i - 1] * b2) % m2;
    }
}

void hashing(string &m, vector<pair<int,int> > &prefix) {
    prefix[0].first = m[0] % m1;
    prefix[0].second = m[0] % m2;

    for (int i = 1; i < m.size(); i++) {
        prefix[i].first = (((prefix[i - 1].first * b1) % m1) + m[i]) % m1;
        prefix[i].second = (((prefix[i - 1].second * b2) % m2) + m[i]) % m2;
    }
}

pair<int,int> get_hash(int l,int r, vector<pair<int,int> > &prefix) {
    if (l == 0) {
        return prefix[r];
    }
    return {
        (prefix[r].first - ((prefix[l - 1].first * power1[r - l + 1]) % m1) + m1) % m1,
        (prefix[r].second - ((prefix[l - 1].second * power2[r - l + 1]) % m2) + m2) % m2
    };
}

// int lcp (int l1,int l2,int len,vector<pair<int,int>> &prefix) {
//     int l = 0,r = len - 1;
//     int ans = -1;
//     while(l<=r) {
//         int mid = (l+r)>>1;
//         if (get_hash(l1,l1+mid,prefix) == get_hash(l2,l2+mid,prefix)) {
//             ans = mid;
//             l = mid + 1;
//         }else {
//             r = mid - 1;
//         }
//     }
//
//     return ans; // the distance from l1 to the last element in the good prefix.  -1 mean first element not match.
// }



struct segTree {
#define lf (x * 2 + 1)
#define rt (x * 2 + 2)
#define md ((lx + rx) >> 1)

    vector<pair<int,int>> seg;
    int sz;

    void init(string &m) {
        sz = m.size();
        seg.assign(sz * 4,{});

        built(m,0,sz - 1,0);
    }

    pair<int,int> merge(pair<int,int> a,pair<int,int> b,int len) {
        return {(((a.first * power1[len])%m1) + b.first) % m1,
            (((a.second * power2[len]) % m2) + b.second) % m2
        };
    }
    void built(string &m,int lx,int rx,int x) {

        if (lx == rx) {
            seg[x] = {m[lx] % m1,m[lx] % m2};
            return;
        }

        built(m,lx,md,lf);
        built(m,md+1,rx,rt);
        int len = rx - (md+1) + 1;
        seg[x] = merge(seg[lf],seg[rt],len);
    }


    void update(int index,char r,int lx = 0,int rx = -1,int x = 0) {
        if (rx == -1)
            rx = sz - 1;

        if (index > rx or index < lx)
            return;

        if (lx == rx) {
            seg[x] = {r,r};
            return;
        }

        update(index,r,lx,md,lf);
        update(index,r,md+1,rx,rt);

        int len = (rx - (md+1) + 1);
        seg[x] = merge(seg[lf],seg[rt],len);
    }

    pair<pair<int,int>,int> query(int l, int r,int lx = 0,int rx = -1,int x = 0) {
        if (rx == -1)
            rx = sz - 1;
        if (l<=lx and rx <= r) {
            pair<pair<int,int>,int> cur = {{seg[x].first,seg[x].second},rx - lx + 1};
            return cur;
        }

        if (rx < l or r < lx) {
            return {{-1,-1},rx - lx + 1};
        }

        pair<pair<int,int>,int> a = query(l,r,lx,md,lf),b = query(l,r,md+1,rx,rt);
        if (a.first.first == -1) {
            return b;
        }if (b.first.first == -1) {
            return a;
        }
        pair<int,int> cur = merge(a.first,b.first,b.second);
        return {cur,a.second + b.second};
    }
};
void solve() {
    int n,q;
    cin>>n>>q;
    string m;
    cin>>m;
    int sz = m.size();

    gen(n+3);

    segTree st1,st2;
    st1.init(m);

    while(q--) {
        int type;
        cin>>type;

        if (type == 1) {
            int index;char value;
            cin>>index>>value;

            index--;

            st1.update(index,value);
            st2.update(sz - index - 1,value);
        }else {
            int l , r;
            cin>>l>>r;
            l--,r--;
            pair<int,int> v1 = st1.query(l,r).first , v2 = st2.query(sz - r - 1,sz - l - 1).first;
            if (v1 == v2) {
                cout << "YES" << endl;
            }else {
                cout << "NO" << endl;
            }
        }
    }


}

int32_t main() {
    // C OUT << "Hello world";
     JOE
#ifndef ONLINE_JUDGE
    files
#endif
    int t = 1;
    // cin >> t;
    while (t--) {
        solve();
    }
}
